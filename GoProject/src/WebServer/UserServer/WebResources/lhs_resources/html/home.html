<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge" />
	<meta name="viewport" content="width=device-width,initial-scale=1.0" />
	<!-- <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=no" /> -->
	<link rel="icon" href="/lhs_resources/ico/favicon.ico" />
	<!--[if lt IE 9]>
	<script type="text/javascript" src="/lhs_resources/js/third_party/html5shiv.min.js"></script>
	<script type="text/javascript" src="/lhs_resources/js/third_party/respond.min.js"></script>
	<![endif]-->
	
	<!-- ES6 npm install babel-core@old --save -->
	<script type="text/javascript" src="/lhs_resources/js/third_party/browser-polyfill.js"></script>
	<script type="text/javascript" src="/lhs_resources/js/third_party/browser.js"></script>
	
	<!-- vue -->
	<script type="text/javascript" src="/lhs_resources/js/third_party/vue.js"></script>
	<script type="text/javascript" src="/lhs_resources/js/third_party/vue-router.js"></script>
	<script type="text/javascript" src="/lhs_resources/js/third_party/vuex.js"></script>
	
	<!-- element-ui -->
	<script type="text/javascript" src="/lhs_resources/js/third_party/element-ui-index.js"></script>
	<link rel="stylesheet" href="/lhs_resources/css/third_party/element-ui-index.css" />
	
	<!-- nutui -->
	<script type="text/javascript" src="/lhs_resources/js/third_party/nutui.js"></script>
	<link rel="stylesheet" href="/lhs_resources/css/third_party/nutui.css" />
	
	<!-- axios -->
	<script type="text/javascript" src="/lhs_resources/js/third_party/axios.js"></script>
	
	<!-- https://github.com/dankogai/js-base64 support IE -->
	<script type="text/babel" src="/lhs_resources/js/third_party/base64.es6.js"></script>
	
	<!-- https://github.com/js-cookie/js-cookie -->
	<script type="text/javascript" src="/lhs_resources/js/third_party/js.cookie.js"></script>
	
	<title>测试主页</title>
	<style>
		body,html{
			width: 100%;
			height: 100%;
			margin: 0 0 0 0;
		}
		[v-cloak] {
			display: none;
		}
	</style>
</head>

<body>
	<div id="app" v-cloak>
		<h1>{{ title }}</h1>
		<p>
			路由链接：
			<div style='background-color:#e0e0e0'>
				<router-link to="/foo">Go to Foo</router-link>
				<router-link to="/bar">Go to Bar</router-link>
				<router-link to="/bar/small-bar">Go to Small bar</router-link>
			</div>
		</p>
		<p>
			路由页面展示：
			<div style='background-color:#e0e0e0'>
				<keep-alive>
					<router-view></router-view>
				</keep-alive>
			</div>
		</p>
		<p>
			Vuex展示：
			<div style='background-color:#e0e0e0'>
				<current-component></current-component>
				<other-component></other-component>
			</div>
		</p>
	</div>
</body>

<script type="text/javascript">

// 绑定axios到Vue
Vue.prototype.$axios = axios;

// body onload
document.body.onload = function() {
	axios.get('/lhs_resources/img/testimg.png', {
		// `url` is the server URL that will be used for the request
		//url: '/user',

		// `method` is the request method to be used when making the request
		//method: 'get', // default 'get'

		// `baseURL` will be prepended to `url` unless `url` is absolute.
		// It can be convenient to set `baseURL` for an instance of axios to pass relative URLs
		// to methods of that instance.
		//baseURL: 'https://some-domain.com/api/',

		// `transformRequest` allows changes to the request data before it is sent to the server
		// This is only applicable for request methods 'PUT', 'POST', 'PATCH' and 'DELETE'
		// The last function in the array must return a string or an instance of Buffer, ArrayBuffer,
		// FormData or Stream
		// You may modify the headers object.
		//transformRequest: [function (data, headers) {
		//	// Do whatever you want to transform the data
		//
		//	return data;
		//}],

		// `transformResponse` allows changes to the response data to be made before
		// it is passed to then/catch
		//transformResponse: [function (data) {
		//	// Do whatever you want to transform the data
		//
		//	return data;
		//}],

		// `headers` are custom headers to be sent
		//headers: {'X-Requested-With': 'XMLHttpRequest'},

		// `params` are the URL parameters to be sent with the request
		// Must be a plain object or a URLSearchParams object
		//params: {
		//	ID: 12345
		//},

		// `paramsSerializer` is an optional function in charge of serializing `params`
		// (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)
		//paramsSerializer: function (params) {
		//	return Qs.stringify(params, {arrayFormat: 'brackets'})
		//},

		// `data` is the data to be sent as the request body
		// Only applicable for request methods 'PUT', 'POST', 'DELETE , and 'PATCH'
		// When no `transformRequest` is set, must be of one of the following types:
		// - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams
		// - Browser only: FormData, File, Blob
		// - Node only: Stream, Buffer
		//data: {
		//	firstName: 'Fred'
		//},

		// syntax alternative to send data into the body
		// method post
		// only the value is sent, not the key
		//data: 'Country=Brasil&City=Belo Horizonte',

		// `timeout` specifies the number of milliseconds before the request times out.
		// If the request takes longer than `timeout`, the request will be aborted.
		//timeout: 1000, // default is `0` (no timeout)

		// `withCredentials` indicates whether or not cross-site Access-Control requests
		// should be made using credentials
		//withCredentials: false, // default false

		// `adapter` allows custom handling of requests which makes testing easier.
		// Return a promise and supply a valid response (see lib/adapters/README.md).
		//adapter: function (config) {
		//	/* ... */
		//},

		// `auth` indicates that HTTP Basic auth should be used, and supplies credentials.
		// This will set an `Authorization` header, overwriting any existing
		// `Authorization` custom headers you have set using `headers`.
		// Please note that only HTTP Basic auth is configurable through this parameter.
		// For Bearer tokens and such, use `Authorization` custom headers instead.
		//auth: {
		//	username: 'janedoe',
		//	password: 's00pers3cret'
		//},

		// `responseType` indicates the type of data that the server will respond with
		// options are: 'arraybuffer', 'document', 'json', 'text', 'stream'
		//   browser only: 'blob'
		responseType: 'blob', // default 'json'

		// `responseEncoding` indicates encoding to use for decoding responses (Node.js only)
		// Note: Ignored for `responseType` of 'stream' or client-side requests
		//responseEncoding: 'utf8', // default 'utf8'

		// `xsrfCookieName` is the name of the cookie to use as a value for xsrf token
		//xsrfCookieName: 'XSRF-TOKEN', // default 'XSRF-TOKEN'

		// `xsrfHeaderName` is the name of the http header that carries the xsrf token value
		//xsrfHeaderName: 'X-XSRF-TOKEN', // default 'X-XSRF-TOKEN'

		// `onUploadProgress` allows handling of progress events for uploads
		// browser only
		//onUploadProgress: function (progressEvent) {
		//	// Do whatever you want with the native progress event
		//},

		// `onDownloadProgress` allows handling of progress events for downloads
		// browser only
		//onDownloadProgress: function (progressEvent) {
		//	// Do whatever you want with the native progress event
		//},

		// `maxContentLength` defines the max size of the http response content in bytes allowed in node.js
		//maxContentLength: 2000,

		// `maxBodyLength` (Node only option) defines the max size of the http request content in bytes allowed
		//maxBodyLength: 2000,

		// `validateStatus` defines whether to resolve or reject the promise for a given
		// HTTP response status code. If `validateStatus` returns `true` (or is set to `null`
		// or `undefined`), the promise will be resolved; otherwise, the promise will be
		// rejected.
		//validateStatus: function (status) {
		//	return status >= 200 && status < 300; // default (return status >= 200 && status < 300;)
		//},

		// `maxRedirects` defines the maximum number of redirects to follow in node.js.
		// If set to 0, no redirects will be followed.
		//maxRedirects: 5, // default 5

		// `socketPath` defines a UNIX Socket to be used in node.js.
		// e.g. '/var/run/docker.sock' to send requests to the docker daemon.
		// Only either `socketPath` or `proxy` can be specified.
		// If both are specified, `socketPath` is used.
		//socketPath: null, // default null

		// `httpAgent` and `httpsAgent` define a custom agent to be used when performing http
		// and https requests, respectively, in node.js. This allows options to be added like
		// `keepAlive` that are not enabled by default.
		//httpAgent: new http.Agent({ keepAlive: true }),
		//httpsAgent: new https.Agent({ keepAlive: true }),

		// `proxy` defines the hostname and port of the proxy server.
		// You can also define your proxy using the conventional `http_proxy` and
		// `https_proxy` environment variables. If you are using environment variables
		// for your proxy configuration, you can also define a `no_proxy` environment
		// variable as a comma-separated list of domains that should not be proxied.
		// Use `false` to disable proxies, ignoring environment variables.
		// `auth` indicates that HTTP Basic auth should be used to connect to the proxy, and
		// supplies credentials.
		// This will set an `Proxy-Authorization` header, overwriting any existing
		// `Proxy-Authorization` custom headers you have set using `headers`.
		//proxy: {
		//	host: '127.0.0.1',
		//	port: 9000,
		//	auth: {
		//		username: 'mikeymike',
		//		password: 'rapunz3l'
		//	}
		//},

		// `cancelToken` specifies a cancel token that can be used to cancel the request
		// (see Cancellation section below for details)
		//cancelToken: new CancelToken(function (cancel) {
		//}),

		// `decompress` indicates whether or not the response body should be decompressed 
		// automatically. If set to `true` will also remove the 'content-encoding' header 
		// from the responses objects of all decompressed responses
		// - Node only (XHR cannot turn off decompression)
		//decompress: true // default true
	})
	.then(function (response) {
		var p = document.createElement("p");
		p.textContent = "用axios下载图片并展示：";// 相比innerHTML，textContent可防止XSS攻击，因为textContent不会被解释为HTML文本
		document.body.appendChild(p);
		
		//var img = document.createElement("img");
		//img.src = URL.createObjectURL(response.data);
		//document.body.appendChild(img);
		
		var reader = new FileReader();
		reader.readAsArrayBuffer(response.data)
		reader.onload = function() {
			var img = document.createElement("img");
			var pngBase64 = Base64.fromUint8Array(new Uint8Array(this.result)); // https://github.com/dankogai/js-base64
			//console.log(Base64.toUint8Array(pngBase64)); // decode
			img.src = 'data:image/png;base64,' + pngBase64;
			document.body.appendChild(img);
		};
	})
	.catch(function (error) {
		console.log(error);
	});	
}

// 全局注册组件
Vue.component('component-custom', {
	template: '<p>{{ message }}</p>',
	components: {
	},
	props: {
		message: {
			type: String,
			required: true
		}
	},
	data: function () {
		return {};
	},
	watch: {
	},
	methods: {
	},
	computed: {
	},
	beforeCreate: function() {
	},
	created: function() {
	},
	beforeMount: function() {
	},
	mounted: function() {
	},
	beforeUpdate: function() {
	},
	updated: function() {
	},
	activated: function() {
	},
	deactivated: function() {
	},
	beforeDestroy: function() {
	},
	destroyed: function() {
	}
});

// 路由组件Foo
var Foo = {
	template: '<div>foo</div>' ,
	data: function () {
		return {};
	},
	beforeCreate: function(){
	},
	created: function(){
	},
	beforeMount: function(){
	},
	mounted: function(){
	},
	beforeUpdate: function(){
	},
	updated: function(){
	},
	activated: function(){
	},
	deactivated: function(){
	},
	beforeDestroy: function(){
	},
	destroyed: function(){
	},
	// 组件内的守卫
	beforeRouteEnter: function(to, from, next) {
		// 在渲染该组件的对应路由被 confirm 前调用
		// 不！能！获取组件实例 `this`
		// 因为当守卫执行前，组件实例还没被创建
		next();
	},
	beforeRouteUpdate: function(to, from, next) {
		// 在当前路由改变，但是该组件被复用时调用
		// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
		// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
		// 可以访问组件实例 `this`
		next();
	},
	beforeRouteLeave: function(to, from, next) {
		// 导航离开该组件的对应路由时调用
		// 可以访问组件实例 `this`
		next();
	}
};

// 路由组件Bar
var Bar = {
	template: '<div>\
					bar\
					<router-link to="/bar/small-bar">\
						Go to Small bar\
					</router-link>\
					<p>\
						<keep-alive>\
							<router-view></router-view>\
						</keep-alive>\
					</p>\
				</div>'
};

// 路由组件SmallBar
var SmallBar = {
	template: '<div>small bar</div>'
};

// 路由组
var routes = [
	{
		name: 'foo name',
		path: '/foo',
		component: Foo
	},
	{
		name: 'bar name', 
		path: '/bar', 
		component: Bar, 
		children: [
			{
				name: 'blackbar name',
				path: 'small-bar',
				component: SmallBar
			}
		]
	},
	{
		path: '*', 
		redirect:'/foo'
	}
];

// 路由实例
var router = new VueRouter({
	routes: routes
});
router.beforeEach(function(to, from, next) {
    next();
});

// vuex
var vuex = new Vuex.Store({
	state: {
		counter: 0,
	},
	strict: true,
	mutations: {
		increment: function(state, n){
			state.counter += n;
		},
		decrement: function(state, n){
			state.counter -= n;
		}
	},
	actions: { // 可异步执行
		incrementAsync: function(context, n) {
			setTimeout(function(c, n) {
				c.commit('increment', n)
			}, 1500, context, n);
		},
		decrementAsync: function(context, n) {
			setTimeout(function(c, n) {
				c.commit('decrement', n)
			}, 1500, context, n);
		}
	},
	getters: { // 类似计算属性
		computeCounter: function(state) {
			return state.counter + Math.random();
		}
	},
	modules: {
	}
});

// 全局注册组件
Vue.component('other-component', {
	template: '<div>\
					<p>其他组件中的状态: {{ $store.state.counter }}</p>\
					<p>在其他组件中使用getter属性: {{ $store.getters.computeCounter }}</p>\
				</div>'
});
Vue.component('current-component', {
	template: '<div>\
					<p>当前组件中的状态: {{ $store.state.counter }}</p>\
					<p><button @click="add">同步加</button> <button @click="sub">同步减</button></p>\
					<p><button @click="addAsync">异步加</button> <button @click="subAsync">异步减</button></p>\
				</div>',
	methods: {
		add: function() {
			this.$store.commit('increment', 1);
		},
		sub: function() {
			this.$store.commit('decrement', 1);
		},
		addAsync: function() {
			this.$store.dispatch('incrementAsync', 1);
		},
		subAsync: function() {
			this.$store.dispatch('decrementAsync', 1).then(function() {
				// decrementAsync函数执行完成
			})
		}
	},
});

// app
var app = new Vue({
	el: '#app',
	store: vuex,
	router: router,
	data: {
		title: '标题'
	}
});

</script>